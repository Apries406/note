---
title: 多线程到事件循环
id: 40f8dac5-9563-417c-8d6a-3da15c836392
date: 2024-05-05 16:49:57
auther: 406
cover: 
excerpt: 多线程到事件循环 CPU与进程和线程 在计算机中，CPU承担了所有的计算任务，是计算机的核心。 进程作为CPU资源分配的最小单位（是能拥有资源且独立运行的最小单位）。 如果将CPU比作供电机，进程更像一各个工厂，线程这是各个工厂中的车间。 由于供电机的供电能力有限，同一时间内只能有一个工厂在工作。根
permalink: /archives/duo-xian-cheng-dao-shi-jian-xun-huan
categories:
 - qian-duan
tags: 
 - javascript
---

# 多线程到事件循环

## CPU与进程和线程

在计算机中，**CPU**承担了所有的计算任务，是计算机的**核心**。
进程作为CPU**资源分配的最小单位**（是能拥有资源且独立运行的最小单位）。

> 如果将CPU比作供电机，进程更像一各个工厂，线程这是各个工厂中的车间。
> 由于供电机的供电能力有限，同一时间内只能有一个工厂在工作。根据工作流程，每个工厂会在不同时间段获得来自供电机的供电支持。
> 一个工厂内可以包含多个车间，这些个车间共同分享整个工厂的资源。

CPU在同一时刻总是运行一个进程，而其他进程处于其他非运行状态。
CPU使用**时间片轮转调度**来实现多进程运行
一个进程能包含多个线程，这些个线程**共享**分配给进程的资源。

## 多进程的浏览器

在任务管理器中打开 `Microsoft Edge`任务我们发现![Pasted image 20240504161831.png](http://apries.xyz/upload/Pasted%20image%2020240504161831.png)
在浏览器中的每个**标签页**都占用了一个**进程**，因此浏览器是多进程的。

但是实际上，对于计算机来说，每个应用程序都是**一个进程**，而每个应用进程都回被分配许许多多的功能模块，这些个模块使用**子进程**来实现。对于这种使用**子进程**来拓展进程的方法，我们称这个应用是**多进程**的。

## 浏览器的进程

在上图中，我们大致窥见，浏览器包含了这些进程：

- **主进程**
  - 协调控制其他子进程的创建及销毁
  - 浏览器的界面显示，用户的交互，路由历史的前进后退，收藏等操作
  - 将渲染进程获取的内存中的 `Bitmap`绘制到会话界面上
  - 处理不可见操作，如网络请求、文件访问等
- **拓展(插件)进程**
  - 每一种类型的拓展对应一个子进程，当使用该拓展时创建
- **GPU进程**
  - 用于 `3D`图像的绘制等
- **渲染进程(浏览器内核)**
  - 负责页面的渲染，`js`脚本的执行，各种事件的处理等
  - 每个标签页都对应一个渲染进程

对于前端开发者来说，我们更重视**渲染进程**

## 渲染进程

由于渲染进程负责了许多不同的功能模块，因此它也是多线程的

- **GUI渲染进程**
  - 负责页面的布局和绘制
  - 页面需要重绘或回流（重排）时，该线程执行
  - 与JS引擎线程**互斥**，防止了多线程渲染的不可料结果
- **JS引擎线程**
  - 负责解析并执行 `javascript`程序
  - 是单线程的
  - 与GUI渲染进程**互斥**，防止了多线程渲染的不可料结果
- **事件触发线程**
  - 负责事件循环
  - 将满足不同条件的事件加入JS引擎的执行队列中
- **定时触发器线程**
  - `setInterval`与 `setTimeout`所在线程
  - 计时完毕后通知事件触发线程工作
- **异步网络请求线程**
  - 处理网络请求
  - 请求完成后，通知事件触发线程对**回调函数**进行处理

### 为什么GUI渲染进程与JS引擎互斥？

由于JS可以操作DOM元素，如果同时修改元素的属性并进行界面渲染，那么渲染线程得到的结果就不可预料了。

因此，防止渲染结果的不可预料，需要 `GUI渲染进程`和 `JS引擎线程`的**互斥**。

## Event Loop

### 为什么要有事件循环

为什么？双足直立人都知道，**JS是单线程的**。

#### 单线程好处？

- **避免复杂的并发控制**
  - 在多线程环境中，开发者需要处理线程之间的通信、同步和锁定等并发问题，这会增加编程的复杂度。
- **提供一致的运行时环境**
  - 单线程模型有助于确保程序的行为可预测。尤其是在面对共享状态时，能够保证执行顺序的一致性，减少并发引起的不确定性。
  - 在浏览器环境中，`JavaScript`主要用于动态更新页面内容、处理用户交互和操作 `DOM`。`DOM API`并非线程安全的，如果有多个 `JS`线程在同时修改 `DOM`结构，将会导致不可预知的结果和严重错误。因此，通过单线程设计，`JavaScript`确保任何时候只有一个线程访问和修改 `DOM`，从而避免了竞态条件和同步问题。
- **内存占用小，占用资源少**
  - 在资源有限的客户端环境中（如浏览器），如果为每个 `JavaScript`任务都创建一个单独的线程，可能会导致资源消耗过大，影响用户体验。

#### 坏处！！

由于JS的单线程机制，如果我们拥有一个高耗时的任务，就会**阻塞线程**。

由此我们推出了异步操作和事件循环。

### 异步任务

有些任务执行时间非常长，会阻塞JS线程。这部分代码会被推出JS引擎线程而放到任务队列中处理。这样不即时处理的任务代码我们称之为**异步任务**

## 事件循环

> 事件循环是 `JavaScript`执行上下文中的一种机制，用于处理异步操作。它的核心思想是将所有的异步任务放入一个队列中，然后按照队列顺序依次执行，直到队列为空为止。主线程从任务队列中读取事件，这个过程是循环不断的，所以整个机制叫做**Event Loop（事件循环）**
>
> ```javascript
> while (queue.waitForMessage()) {
>     queue.processNextMessage()
> }
> ```

概念讲解：

![Pasted image 20240505115523.png](/upload/Pasted%20image%2020240505115523.png)

- JS分为**同步任务**和**异步任务**。

- 同步任务都在JS引擎线程上执行，形成**执行栈**。
- 事件触发线程管理一个**任务队列**，异步任务达成触发条件时，此线程将其回调函数放到**任务队列中**。
- **执行栈**中的所有同步任务执行完毕后，JS引擎线程空闲，此时再读取**任务队列**，将可运行的一步任务添加到**执行栈**中执行。
- 无论是 `setTimeout/setInterval`还是 `XHR/fetch`，执行时，作为同步任务，其回调才是异步任务。
- 当代码执行到 `XHR/fetch`网络请求时，JS引擎线程通知**异步网络请求线程**发送一个网络请求，并且规定回调函数。**异步网络请求线程**在接收到这个消息后，会在请求完成时将回调时间放入**事件触发线程**管理的**任务队列**中
- 当同步任务执行完后，JS引擎线程会"询问"**事件触发线程**在**任务队列**中是否有在等待执行的回调函数，如果有，就将其加入到**执行栈**中执行

### 宏任务/微任务

#### 宏任务

执行栈每次执行的代码就是**宏任务**(包括每次从任务队列中获取一个回调任务放到执行栈中执行)，宏任务会从头到尾执行完毕（因为微任务是**非抢断式的高优先级任务**）

前文提到：**JS引擎和GUI渲染线程互斥**。浏览器为了能让**宏任务**和**DOM渲染**有序进行，会在一个宏任务结束之后，下一个宏任务执行前渲染DOM。

> 宏任务 → 渲染 → 宏任务

**主代码块**、**setTimeout**、**setInterval**、**I/O**、**requestAnimationFrame**、**requestidleCallback**等，都属于**宏任务**也叫**tasks**
🌰：

```javascript
document.body.style = 'background:red';
document.body.style = 'background:yellow';
document.body.style = 'background:blue';
```

以上代码同属主代码块，整体是**一个宏任务**， 因此页面只会在结束后渲染，背景为蓝色。

```javascript
document.body.style = 'background:red';
document.body.style = 'background:yellow';
setTimeout(()=>{
	document.body.style = 'background:blue';
},0)
```

以上代码属于两次宏任务，第一次宏任务将背景变成黄色，然后触发渲染，再执行第二次宏任务后将背景变成蓝色。

#### 微任务

前面说到，宏任务执行结束后会执行渲染，再执行下一个宏任务。
是一个**非抢占式的高优先级**任务
**微任务**也叫**jobs**，常见的微任务来源有：

- **Promise**
- **async/await**(源码也是依靠Promise实现的)
- **process.nextTick()** (node环境存在)
- **MutationObserver()**

🌰：

```javascript
setTimeout(() => {
	console.log(1)
	Promise.resolve(3).then((data) => console.log(data))
}, 0)

setTimeout(() => {
	console.log(2)
}, 0)
```

上述代码的输出结果是 `1 3 2`。共创建了两个宏任务，在第一个宏任务中随之创建了一个微任务，因此在没完成微任务时，不得进行第二个宏任务。
