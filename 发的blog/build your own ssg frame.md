---
title: build your own ssg frame
id: f4dd3a63-7bb8-4f96-87e1-32901408aee3
date: 2024-08-13 11:52:46
auther: 406
cover: null
excerpt: BUILD YOUR OWN SSG FRAME WITH NODEJS 基础版本 要构建一个类似于 Rspress 的静态站点生成器（SSG）框架，我们需要以下几个步骤： 创建项目结构：设定目录结构以便组织代码和配置。 设置构建工具：选择并配置适合的构建工具。 处理模板和内容：解析模板和内容文件，
permalink: /archives/build-your-own-ssg-frame
categories:
tags: 
---

# BUILD YOUR OWN SSG FRAME WITH NODEJS


# 基础版本

要构建一个类似于 **Rspress** 的静态站点生成器（SSG）框架，我们需要以下几个步骤：

**创建项目结构**：设定目录结构以便组织代码和配置。

**设置构建工具**：选择并配置适合的构建工具。

**处理模板和内容**：解析模板和内容文件，生成静态 HTML 文件。

**生成静态文件**：将生成的 HTML 文件输出到构建目录。

**开发本地开发服务器**：提供本地开发和预览功能。

**支持其他功能**：如动态路由、数据源支持等。

下面是一个基本的实现步骤，以 Node.js 为例来构建一个简单的 SSG 框架：

### 1. **创建项目结构**

首先，创建一个新的目录来存放你的项目，并初始化一个新的 Node.js 项目：

```
bashmkdir my-ssgcd my-ssgnpm init -y
```

然后，创建以下目录和文件结构：

```
my-ssg/├── src/│   ├── templates/│   ├── content/│   └── index.js├── public/│   └── assets/├── build/├── package.json└── README.md
```

### 2. **安装必要的依赖**

安装需要的 Node.js 模块，例如：ejs 用于模板渲染，fs-extra 用于文件操作，chokidar 用于监视文件变化（用于开发模式）：

```
npm install ejs fs-extra chokidar
```

### 3. **编写模板和内容**

在 src/templates/ 目录中创建一个简单的模板文件 template.ejs：

```
<!DOCTYPE html><html><head>  <meta charset="UTF-8">  <title><%= title %></title></head><body>  <h1><%= title %></h1>  <div><%= content %></div></body></html>
```

在 src/content/ 目录中创建一个示例内容文件 index.md：

```
# Hello World Welcome to my static site generated by my custom SSG framework!
```

### 4. **实现静态文件生成**

在 src/index.js 中实现基本的 SSG 逻辑：

```
const fs = require('fs-extra');const path = require('path');const ejs = require('ejs');const markdown = require('markdown').markdown;const chokidar = require('chokidar'); // Pathsconst contentDir = path.join(__dirname, 'content');const templateFile = path.join(__dirname, 'templates', 'template.ejs');const outputDir = path.join(__dirname, '../build'); // Read the templateconst template = fs.readFileSync(templateFile, 'utf8'); // Process content filesasync function processContentFile(filePath) {  const fileName = path.basename(filePath, '.md');  const fileContent = fs.readFileSync(filePath, 'utf8');   // Convert Markdown to HTML  const htmlContent = markdown.toHTML(fileContent);   // Render the template with content  const html = ejs.render(template, {    title: fileName.charAt(0).toUpperCase() + fileName.slice(1),    content: htmlContent  });   // Write the output file  fs.outputFileSync(path.join(outputDir, `${fileName}.html`), html);} // Build functionasync function build() {  // Clear the output directory  fs.emptyDirSync(outputDir);   // Process each Markdown file in the content directory  const files = fs.readdirSync(contentDir).filter(file => file.endsWith('.md'));  for (const file of files) {    await processContentFile(path.join(contentDir, file));  }   console.log('Build completed!');} // Watcher for developmentfunction watch() {  chokidar.watch(contentDir).on('change', () => {    console.log('Changes detected. Rebuilding...');    build();  });} // Run the build processbuild();if (process.env.NODE_ENV === 'development') {  watch();} 
```

### 5. **实现本地开发服务器**

为了提供本地开发和预览功能，你可以使用 express 或其他 HTTP 服务器模块。安装 express：

```
npm install express
```

然后在 src/index.js 中添加一个简单的开发服务器：

```
const express = require('express');const app = express();const port = 3000; // Serve static files from the build directoryapp.use(express.static(path.join(__dirname, '../build'))); // Start the serverapp.listen(port, () => {  console.log(`Server is running at http://localhost:${port}`);});
```

### 6. **运行和测试**

**构建静态文件**：在构建时，使用命令：

```
NODE_ENV=production node src/index.js
```

**开发模式**：在开发模式下，监视内容文件变化并启动开发服务器：

```
NODE_ENV=development node src/index.js
```

访问 http://localhost:3000 查看生成的静态页面。

### 总结

这是一个非常基础的静态站点生成器实现，涵盖了静态文件生成、模板渲染、内容处理、和本地开发服务器。实际的框架可能需要更多的功能，如动态路由、数据源支持、更复杂的模板系统等。

# 进阶模式

要构建一个更复杂的静态站点生成器（SSG），支持动态路由、数据源支持，并能够渲染 React 组件，可以参考以下步骤。我们将依次扩展静态站点生成器的功能，集成动态路由和数据源支持，并实现 React 组件的渲染。

### 1. **扩展项目结构**

增加对数据源的支持、动态路由和 React 组件渲染的文件结构：

```
my-ssg/├── src/│   ├── components/         # React 组件│   ├── content/            # 内容文件│   ├── data/               # 数据源│   ├── pages/              # 页面模板│   ├── routes/             # 动态路由│   ├── templates/          # 页面模板│   ├── index.js            # 构建逻辑│   └── server.js           # 开发服务器├── public/│   └── assets/├── build/├── package.json└── README.md
```

### 2. **安装必要的依赖**

除了之前安装的依赖，我们还需要 react、react-dom、@babel/core、@babel/preset-env、@babel/preset-react、babel-loader 来支持 React 渲染：

```
npm install react react-domnpm install @babel/core @babel/preset-env @babel/preset-react babel-loadernpm install webpack webpack-cli webpack-node-externals html-webpack-plugin --save-dev
```

### 3. **设置 Babel 和 Webpack**

创建 .babelrc 配置文件以支持 React 和现代 JavaScript 特性：

```
{  "presets": ["@babel/preset-env", "@babel/preset-react"]}
```

创建 webpack.config.js 配置文件以打包 React 组件：

```
const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const nodeExternals = require('webpack-node-externals'); module.exports = {  entry: './src/index.js',  output: {    path: path.resolve(__dirname, 'build'),    filename: 'bundle.js',  },  module: {    rules: [      {        test: /\.js$/,        exclude: /node_modules/,        use: {          loader: 'babel-loader',        },      },    ],  },  externals: [nodeExternals()],  target: 'node',  node: {    __dirname: false,  },};
```

### 4. **实现动态路由**

在 src/routes/ 目录中添加路由配置文件 routes.js：

```
const path = require('path');const fs = require('fs-extra'); const routesDir = path.join(__dirname, 'routes');const routes = fs.readdirSync(routesDir).map(file => path.join(routesDir, file)); module.exports = routes;
```

在 src/pages/ 目录中添加示例页面文件 home.js：

```
import React from 'react'; const Home = () => (  <div>    <h1>Welcome to My Static Site!</h1>    <p>This is the home page.</p>  </div>); export default Home; 
```

### 5. **支持数据源**

在 src/data/ 目录中创建一个示例数据文件 posts.json：

```
[  {    "id": "1",    "title": "First Post",    "content": "This is the content of the first post."  },  {    "id": "2",    "title": "Second Post",    "content": "This is the content of the second post."  }]
```

### 6. **渲染 React 组件**

更新 src/index.js 以支持 React 组件的渲染，并集成动态路由和数据源支持：

```
const fs = require('fs-extra');const path = require('path');const ejs = require('ejs');const React = require('react');const ReactDOMServer = require('react-dom/server');const { promisify } = require('util');const routes = require('./routes');const posts = require('./data/posts.json'); // Pathsconst templateFile = path.join(__dirname, 'templates', 'template.ejs');const outputDir = path.join(__dirname, '../build'); // Read the templateconst template = fs.readFileSync(templateFile, 'utf8'); // Process pagesasync function processPage(filePath, data) {  const fileName = path.basename(filePath, '.js');  const PageComponent = require(filePath).default;   // Render React component to HTML  const htmlContent = ReactDOMServer.renderToString(<PageComponent data={data} />);   // Render the template with content  const html = ejs.render(template, {    title: fileName.charAt(0).toUpperCase() + fileName.slice(1),    content: htmlContent  });   // Write the output file  fs.outputFileSync(path.join(outputDir, `${fileName}.html`), html);} // Build functionasync function build() {  // Clear the output directory  fs.emptyDirSync(outputDir);   // Process each page file in the pages directory  const files = fs.readdirSync(path.join(__dirname, 'pages')).filter(file => file.endsWith('.js'));  for (const file of files) {    const filePath = path.join(__dirname, 'pages', file);    await processPage(filePath, posts);  }   console.log('Build completed!');} // Watcher for developmentfunction watch() {  const chokidar = require('chokidar');  chokidar.watch(path.join(__dirname, 'content')).on('change', () => {    console.log('Changes detected. Rebuilding...');    build();  });} // Run the build processbuild();if (process.env.NODE_ENV === 'development') {  watch();} 
```

### 7. **本地开发服务器**

在 src/server.js 中创建一个开发服务器以提供静态文件和动态内容：

```
const express = require('express');const path = require('path');const fs = require('fs-extra');const app = express();const port = 3000; // Serve static files from the build directoryapp.use(express.static(path.join(__dirname, '../build'))); // Handle dynamic routesapp.get('*', (req, res) => {  const filePath = path.join(__dirname, '../build', req.path === '/' ? 'index.html' : `${req.path}.html`);if (fs.existsSync(filePath)) {    res.sendFile(filePath);  } else {    res.status(404).send('Page not found');  }}); // Start the serverapp.listen(port, () => {  console.log(`Server is running at http://localhost:${port}`);}); 
```

### 8. **运行和测试**

**构建静态文件**：运行构建命令：

```
NODE_ENV=production node src/index.js
```

**开发模式**：监视内容文件变化并启动开发服务器：

```
NODE_ENV=development node src/server.js
```

访问 http://localhost:3000 查看生成的静态页面。

### 总结

通过以上步骤，你构建了一个基础的静态站点生成器，支持动态路由、数据源，并能够渲染 React 组件。这个实现包含了以下功能：

**动态路由**：根据 src/routes/ 目录中的路由配置生成静态文件。

**数据源支持**：从 src/data/ 目录加载数据，并将其传递给 React 组件。

**React 组件渲染**：使用 react 和 react-dom 进行组件渲染，并将其集成到生成的静态页面中。

可以在这个基础上进行扩展和优化，以支持更多的功能和配置。希望这能帮助你启动并构建你的静态站点生成器项目！
