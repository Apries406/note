# 深浅拷贝

## 什么是深浅拷贝
### 浅拷贝
*浅拷贝*是创建一个新对象，但是该新对象的元素仍然是原始对象的引用。也就是说，在钱拷贝中，若：
- 属性是**基本类型**：拷贝基本类型的**值**
- 属性是**引用类型**：拷贝**内存地址**，新对象和原始对象共享内存地址，当修改其中一个对象时，另一个对象也会受到影响。
因此，浅拷贝通常适用于简单的数据结构。
#### 浅拷贝与赋值有何区别？
>[!info]
>**赋值**: 当我们把一个对象赋值给一个新对象时，新对象得到的其实是原始对象在栈中的地址，而不是堆中的数据值。也就是两个对象其实指向同一个空间，无论哪个对象修改自己的属性，另一个对象也会随之改变。就像两个人拿了同一个房间的钥匙，无论哪个人改变了屋内的布局，都会对房间造成影响。
>
>**浅拷贝**: 当我们以浅拷贝方法复制一个对象时，会在堆中重新分配内存。拷贝前后，新对象与原始对象的中属于基本数据类型的部分互不影响，但是属于引用类型的数据类型仍然共享同一块内存，因此依然会影响。

```javascript
const obj = {
	name: 'apries',
	info: [20, 'Male', 'ChengDu'],
}

const obj1 = obj
obj1.name = 'Apries'
obj1.info[2] = 'China'

console.log(obj) // { name: 'Apries', info: [ 20, 'Male', 'China' ] }
console.log(obj1) // { name: 'Apries', info: [ 20, 'Male', 'China' ] }

const obj2 = shallowCopy(obj)

obj2.name = 'apries'
obj2.info[2] = 'ChengDu'

console.log(obj) // { name: 'Apries', info: [ 20, 'Male', 'ChengDu' ] }
console.log(obj1) // { name: 'Apries', info: [ 20, 'Male', 'ChengDu' ] }
console.log(obj2) // { name: 'apries', info: [ 20, 'Male', 'ChengDu' ] }

function shallowCopy(obj) {
	let copied = {}
	for (let key in obj) {
		if (obj.hasOwnProperty(key)) {
			copied[key] = obj[key]
		}
	}

	return copied
}
```

### 深拷贝
*深拷贝*是指创建一个新对象，拷贝前后，新对象与原始对象的属性完全独立，不存在引用关系。只是新对象与原始对象的属性值完全一样。无论怎样修改自身属性，另一个对象都不会受到影响。
因此，深拷贝适用于复杂的数据结构，如*嵌套的对象*和*多维数组*。
## 如何实现一个浅拷贝？
### Object.assign()
>[!info]
>`Object.assign(target, ...sources)`
如果目标对象与源对象具有相同的属性名，则目标对象中的属性将被源对象中的属性覆盖。
其外，会将源对象的**可枚举的**自有属性拷贝到靶对象。
该方法在源对象上使用`[[Get]]`，在目标对象上使用`[[Set]]`，因此它会调用`getter`和`setter`。故它对属性赋值，而不仅仅是赋值或定义新的属性。如果要将属性定义（包括它们的可枚举性）复制到原型中，则应改用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperty()` 方法。
`字符串`和 `Symbol` 类型属性都会被复制。
如果赋值期间出错，例如如果属性不可写，则会抛出 `TypeError`；如果在抛出异常之前已经添加了一些属性，则这些属性会被保留，而 `target` 对象也会被修改。
`Object.assign()` 不会在源对象值为 `null` 或 `undefined` 时抛出错误。

```javascript
const obj = {
	name: 'apries',
	info: [20, 'Male', 'ChengDu'],
}

const obj1 = Object.assign({}, obj)

obj1.name = 'Apries'
obj1.info[2] = 'China'
console.log(obj)// { name: 'apries', info: [ 20, 'Male', 'China' ] }
console.log(obj1)// { name: 'Apries', info: [ 20, 'Male', 'China' ] }
```

### 展开运算符(...)
`...(展开运算符)`是$ES6$特性，它提供了与`Object.assign()`一样效果的但更为简洁的浅拷贝方法。
```javascript
const obj = {
	name: 'apries',
	info: [20, 'Male', 'ChengDu'],
}

const obj1 = { ...obj }

obj1.name = 'Apries'
obj1.info[2] = 'China'
console.log(obj) // { name: 'apries', info: [ 20, 'Male', 'China' ] }
console.log(obj1) // { name: 'Apries', info: [ 20, 'Male', 'China' ] }
```
### Array.prototype.concat()
>[!info]
>```javascript
concat()
concat(value0)
concat(value0, value1)
concat(value0, value1,..., valueN)
>```
>如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个**浅拷贝**。

```javascript
const arr = [
	'apries',
	20,
	'Male',
	'ChengDu',
	{
		name: 'apries',
		info: [20, 'Male', 'ChengDu'],
	},
]

const arr1 = arr.concat()
arr1[0] = 'Apries'
arr1[4].name = 'Apries'
console.log(arr)
console.log(arr1)
/*
output:
[
  'apries',
  20,
  'Male',
  'ChengDu',
  { name: 'Apries', info: [ 20, 'Male', 'ChengDu' ] }
]
[
  'Apries',
  20,
  'Male',
  'ChengDu',
  { name: 'Apries', info: [ 20, 'Male', 'ChengDu' ] }
]
*/
```

### Array.prototype.slice()
>[!info]
>`slice()`方法返回一个新的数组对象，这一对象是一个由 `start` 和 `end` 决定的原数组的浅拷贝（包括 `start`，不包括 `end`），其中 `start` 和 `end` 代表了数组元素的索引。原始数组不会被改变。

```javascript
const arr = [
	'apries',
	20,
	'Male',
	'ChengDu',
	{
		name: 'apries',
		info: [20, 'Male', 'ChengDu'],
	},
]

const arr1 = arr.slice()
arr1[0] = 'Apries'
arr1[4].name = 'Apries'
console.log(arr)
console.log(arr1)
/*
output:
[
  'apries',
  20,
  'Male',
  'ChengDu',
  { name: 'Apries', info: [ 20, 'Male', 'ChengDu' ] }
]
[
  'Apries',
  20,
  'Male',
  'ChengDu',
  { name: 'Apries', info: [ 20, 'Male', 'ChengDu' ] }
]
*/
```

## 如何实现一个深拷贝
### JSON.parse(JSON.stringify())
``