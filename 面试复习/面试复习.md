# HTML
# CSS 
## BFC
全称`block fromatting context`,简称`BFC`。
它是一块独立的**渲染区域**，规定了在**常规流**（浮动、定位）块盒的布局。
### 常规流块盒
- 常规流块盒在水平方向上必须撑满包含块
- 常规流块盒在包含块的垂直方向上依次摆放
- 常规流块盒若外边距无缝相邻，则外边距合并
- 常规流块盒的自动高度和摆放位置，无视浮动元素
### BFC渲染区域
这个区域由某个`HTML`元素创建，以下元素会在其内部创建BFC区域：
- 根元素
- 浮动和绝对定位元素
- overflow不等于visible的块盒
# Javscript

## 设置不允许修改的对象属性
### `Object.degfineProperty(obj, prop, descriptor)`
描述符：
- **数据描述符**：具有可写或不可写值的属性
- **访问器描述符**：

## async/await和promise
### 用法
`async` 表示函数里面有异步操作
`await` 表示紧跟再后面的表达式需要等待结果
同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体后面的语句。
### 优点
- 方便级联调用
- 异步函数的同步代码编写方式
- 多个参数传递
- 是对Promise的优化
### async关键字
- 表明程序里面可能有异步过程
- 非阻塞
- async函数返回类型为Promise对象
- 无等待
- await不处理异步error

## new操作符
在`javascript`中，`new`操作符用于创建一个给定构造函数的实例对象
``` javascript
function Person(name, age) {
	this.name = name;
	this.age = age;
}
Person.prototype.sayName = function() {
	console.log(this.name)
}

const person1 = new Person('Tom',20)
console.log(person1) // Person {name: 'Tom', age: 20}
t.sayName() // 'Tom'
```
从上面可以看到：
- `new`通过构造函数`Person`创建出来的实例可以访问到构造函数中的属性
- `new`通过构造函数`Person`创建出来的实例可以访问函数原型链种的属性
在构造函数中，会发生：
- 函数体逻辑顶层隐式加上`let this = {}`
- 执行函数体`this.xxx = xxx`
- 隐式返回`this`
所以`new`操作符做了如下工作：
- 创建一个新的对象`obj`
- 将对象与构建函数通过原型链连接起来
- 将构建函数种的`this`绑定到对象`obj`上
- 根据构建函数返回类型作为判断，如果是原始值则被忽略，如果是对象则正常处理
**制作自己的new操作:**
```javascript
function Anew(func, ...args) {
	const obj = {}
	obj.__proto__ = func.prototype // * 对象与构造函数的原型链连接起来

	const res = func.apply(obj, args) // * 将构造函数的this绑定到obj上面

	return res instanceof Object ? res : obj // * 返回实例对象或构造函数本身
}
function Person(name, age) {
	this.name = name
	this.age = age
}
Person.prototype.say = function () {
	console.log(this.name)
}

let p1 = Anew(Person, 'Tom', 20)
p1.say() // 'Tom'
console.log(p1) // Person { name: 'Tom', age: 20 }
```

## 本地存储方案
- cookie
- sessionStorage
- localStorage
- indexedDB
### cookie
`Cookie`，类型为「**小型文本文件**」，指某些网站为了辨别用户身份而存储在用户本地终端上的数据。是为了解决`HTTP`无状态导致的问题

作为一段一般不超过4KB的小型文本数据，它由一个名称`Name`、一个值`Value`和其他几个控制`cookie`有效期、安全性、使用范围的可选属性组成

但是`cookie`在每次请求种都会被发送，如果不使用`HTTPS`并对其加密，其保存的信息很容易被窃取，导致风险。

常用属性如下：
- `Expires` 用于设置`Cookie`的过期时间
```javascript
Expires= Wed, 21 oct 2024 07:28:00 GMT
```
- `Max-Age` 用于设置在`Cookie`时效前需要经过的秒数，优先级高于`Expires`
```javascript
Max-Age=604800 // 七天后过期
```
- `Domain` 指定了`Cookie`可以送达的主机名
- `Path` 指定了一个`URL`路径，这个路径必须出现在要请求的路径中才可以发送`Cookie`首部
```javascript
Path=/docs     // /docs/Web/ 下的资源会带Cookie首部
```
- 标记为`Secure`的`Cookie`只应被`HTTPS`协议加密过的请求发送给服务端

### localStorage

#### 特点
- 持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的
- 储存的信息在同一域中是共享的
- `localStorage`本质上是对字符串的读取，如果存储内容过多会消耗内存空间，导致页面变卡
#### 使用
```javascript
// 设置
localStorage.setItem('username', 'cfangxu')
// 获取
localStorage.getItem('username')
// 获取键名
localStorage.key(0) // 获取第一个键名
// 删除
localStorage.removeItem('username')
// 一次性清除所有存储
localStorage.clear()
```

#### 缺点
- 无法像`Cookie`一样设置过期时间
- 只能存入字符串，无法直接存对象
### sessionStorage
`sesssionStorage`和`localStorage`使用方法基本一致，唯一不同的是生命周期，一旦页面(会话)关闭，`sessionStorage`将删除存储数据

### 拓展前端存储方式 
`indexedDB`是一种低级API，用于客户端存储大量结构化数据（文件、blobs）该API使用索引来实现对该数据的高性能搜索
- `Godb.js`
### 区别
- 存储大小：`cookie`数据大小不得超过`4KB`,`sessionStorage`和`localStorage`能达到`5MB`左右或更大
- 有效时间：
	- `localStorage`存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
	- `sessionStorage`数据再当前浏览器（会话）关闭之后自动删除
	- `cookie`再到达设置的过期时间之前一直有效，即使浏览器（会话）关闭
- 数据与服务器之间的交互方式
	-  `cookie`的数据会自动的传递到服务器，服务端也可以写`cookie`到客户端
	- `sessionStorage`和`localStorage`不会把数据发送给服务器，仅在本地保存
### 应用场景
- 标记用户与跟踪用户行为的情况，推荐使用`cookie`
- 适合长期保存在本地的数据(令牌)，推荐使用`localStorage`
- 敏感账号一次性登录，推荐使用`sessionStorage`
- 存储大量数据的情况、在线文档(富文本编辑器)保存编辑历史的情况，推荐`indexedDB`
## 柯里化
### 自动柯里化转换
```javascript
// * 自动柯里化转化
const curryIt = (fn) => {
	console.log(fn.length)
	function curriedFn(...args) {
		if (args.length >= fn.length) {
			// * 参数足够 fn.length 代表fn期望得到的参数个数
			// * 执行fn
			// * 满足外部apply调用
			return fn.apply(this, ...args)
		} else {
			// * 继续返回新函数，继续接受参数
			return function (...args2) {
				// * 满足外部apply调用
				return curriedFn.apply(this, ...args.concat(args2))
			}
		}
	}

	return curriedFn
}

function foo(a, b, c) {
	return a + b + c
}

let fooCurried = curryIt(foo)
const a = fooCurried(1)(2)(3) // 6
console.log(a)

```

## with / eval
```javascript
let obj = {
	message: 'Hello, world!',
}
// * with语句
with (obj) {
	console.log(message)
}

// * eval函数
var codeString = "console.log('Hello, world!')"
eval(codeString)
```

## 事件循环

### 浏览器包含了哪些进程
- 主进程
	- 协调控制其他子进程（创建、销毁）
	- 浏览器界面显示，用户交互，前进，后退，收藏
	- 将渲染进程得到的内存种的`Bitmap`，绘制到用户界面上
	- 处理不可见操作，网络请求，文件访问等
- 第三方插件
	- 每种类型的插件对应一个进程，仅使用该插件时才创建
- GPU进程
	- 用于3D绘制等
- **渲染进程**，就是我们说的**浏览器内核**
	- 负责页面渲染，脚本执行，事件处理等
	- 每个tab页一个渲染进程

### 渲染进程

- **GUI渲染线程**
	- 负责渲染页面，布局和绘制
	- 页面需要重绘和回流时，该线程就会执行
	- 与JS引擎线程互斥，防止渲染结果不可预期


