# 数组交/差/并集
```javascript
const arr1 = [33, 22, 22, 55, 33, 11, 33, 5]
const arr2 = [22, 22, 55, 77, 88, 88, 99, 99]

const union = Array.from(new Set([...arr1, ...arr2]))

const intersection = Array.from(new Set(arr1.filter((x) => arr2.includes(x))))

const difference = Array.from(new Set(arr1.filter((x) => !arr2.includes(x))))

console.log(union)
console.log(intersection)
console.log(difference)
```

# 惰性函数
惰性函数表示在函数执行的过程中，函数会在首次成功调用时**重写**

由于浏览器行为之间的差异（兼容性问题），我们在处理这些问题时，常常需要考虑某种`webAPI`是否受当前浏览器支持。此时我们就需要根据浏览器环境使用分支语句来处理差异实现兼容适配

如剪切板操作：
```javascript
function copyText(text) {
	if (navigator.clipboard) {
		navigator.clipboard.writeText(text)
	} else {
		const ipt = document.createElement('input')
		ipt.setAttribute('value', text)
		document.body.appendChild(ipt)
		ipt.select()
		document.execCommand('copy')
		documnt.body.removeChild(ipt)
	}
}
```

但是当我们函数运行之后，其实就已经确定了浏览器的兼容状况。而我们的代码在每一次执行时都回去判断，为了避免这样无意义的判断，我们使用**惰性函数**
```javascript
function copyText(text) {
	if (navigator.clipboard) {
		copyText = (text) => navigator.clipboard.writeText(text)
	} else {
		copyText = (text) => {
			const ipt = document.createElement('input')
			ipt.setAttribute('value', text)
			document.body.appendChild(ipt)
			ipt.select()
			document.execCommand('copy')
			document.body.removeChild(ipt)
		}
	}
}
```

在浏览器中呈现如下:
![[Pasted image 20240425132529.png]]
由于我的浏览器支持`navigator.clipboard`，所以再次运行后，函数重写为这一分支。
后续无需再次使用分支语句判断。

# FetchApi的请求取消
```javascript
let controller
const handleFetch = async () => {
	// * 取消上次的请求
	controller && controller.abort()
	controller = new AbortController()
	const list = fetch('XXXXXXXXXXXXXXXXXXXXXXXX', ariaValueMax, {
		signal: controller.signal,
	}).then((response) => response.json())
}

```

# javascript隐式转换

一些奇怪的`==`结果
```javascript
[] == ![] // true
[] == 0 // true
[2] == 2 // true
['0'] == false // true
'0' == false // true
[] == false // true
[null] == 0 // true
null == 0 // false
[null] == false // true
null == false // false
[undefined] == false // true
undefined == false // false
```

## String() 显示转换
- null：转化为`"null"`
- undefined：转为`"undefined"`
- 布尔类型：`true`->`"true""` `false`->`"false"`
- 数字类型：转换为数字的字符串形式
	- `10` -> `"10"`
	- `1e21`->`"1e+21"`
- 数组: 转换为字符串是将所有的字符按照`,`连接起来，相当于调用数组的`Array.prototype.join()`方法
	- `[1, 2, 3]` -> `"1,2,3"`
	- `[]`->`""` 数组中的`null`和`undefined`会被当做空字符串处理
	- `[null]`->`""`
	- `[1,undefined,3]`->`"1,,3"`
- 普通对象：转为字符串相当于直接使用`Object.prototype.toString()`
	- `String({})`->`[object Object]`