# 数组交/差/并集
```javascript
const arr1 = [33, 22, 22, 55, 33, 11, 33, 5]
const arr2 = [22, 22, 55, 77, 88, 88, 99, 99]

const union = Array.from(new Set([...arr1, ...arr2]))

const intersection = Array.from(new Set(arr1.filter((x) => arr2.includes(x))))

const difference = Array.from(new Set(arr1.filter((x) => !arr2.includes(x))))

console.log(union)
console.log(intersection)
console.log(difference)
```

# 惰性函数
惰性函数表示在函数执行的过程中，函数会在首次成功调用时**重写**

由于浏览器行为之间的差异（兼容性问题），我们在处理这些问题时，常常需要考虑某种`webAPI`是否受当前浏览器支持。此时我们就需要根据浏览器环境使用分支语句来处理差异实现兼容适配

如剪切板操作：
```javascript
function copyText(text) {
	if (navigator.clipboard) {
		navigator.clipboard.writeText(text)
	} else {
		const ipt = document.createElement('input')
		ipt.setAttribute('value', text)
		document.body.appendChild(ipt)
		ipt.select()
		document.execCommand('copy')
		documnt.body.removeChild(ipt)
	}
}
```

但是当我们函数运行之后，其实就已经确定了浏览器的兼容状况。而我们的代码在每一次执行时都回去判断，为了避免这样无意义的判断，我们使用**惰性函数**
```javascript
function copyText(text) {
	if (navigator.clipboard) {
		copyText = (text) => navigator.clipboard.writeText(text)
	} else {
		copyText = (text) => {
			const ipt = document.createElement('input')
			ipt.setAttribute('value', text)
			document.body.appendChild(ipt)
			ipt.select()
			document.execCommand('copy')
			document.body.removeChild(ipt)
		}
	}
}
```

在浏览器中呈现如下:
![[Pasted image 20240425132529.png]]
由于我的浏览器支持`navigator.clipboard`，所以再次运行后，函数重写为这一分支。
后续无需再次使用分支语句判断。

# FetchApi的请求取消
```javascript
let controller
const handleFetch = async () => {
	// * 取消上次的请求
	controller && controller.abort()
	controller = new AbortController()
	const list = fetch('XXXXXXXXXXXXXXXXXXXXXXXX', ariaValueMax, {
		signal: controller.signal,
	}).then((response) => response.json())
}

```